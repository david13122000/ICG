<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Game</title>
    <!-- <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        .message-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none; /* Hide initially */
        }
    </style> -->
</head>
<body>
    <!-- <div class="message-container" id="messageContainer">
        <h1>Congratulations! You won the game!</h1>
        <button id="restartButton">Restart Game</button>
    </div> -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.135.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/controls/OrbitControls.js';
        import { FirstPersonControls } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/controls/FirstPersonControls.js';

        // Scene
        const scene = new THREE.Scene();        
        
        // Camera
        const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera1.position.set(0, 60, 65); // Position the camera above the maze
        camera1.rotation.x = -Math.PI / 4; // Tilt the camera to look down
        scene.add(camera1);
 
        //Camera 2 for first person view
        const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera2.position.set(2.5, 3, 55); 
        camera2.rotation.set(0, Math.PI, 0); 
        scene.add(camera2);

      

        let isFirstPersonCamera = false;
        window.addEventListener('keydown', function(event) {
            // Check if the pressed key is 'C' (key code 67)
                if (event.keyCode === 67) {
                    toggleCamera(); // Call toggleCamera function to switch cameras
                }
            });
        // Function to toggle between cameras
        function toggleCamera() {
            isFirstPersonCamera = !isFirstPersonCamera; // Toggle the camera boolean
            console.log("Toggling camera. First person camera:", isFirstPersonCamera);
            if (isFirstPersonCamera) {
                camera1.layers.enable(1); // Enable camera1
                camera2.layers.disable(1); // Disable camera2
                // Enable controls for camera2
                firstPersonControls.enabled = true;
            } else {
                camera1.layers.disable(1); // Disable camera1
                camera2.layers.enable(1); // Enable camera2
                // Disable controls for camera2
                firstPersonControls.enabled = false;
            }
        }

        // Renderer
        const controls = new OrbitControls(camera1, document.body);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.rotateSpeed = 0.35;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const firstPersonControls = new FirstPersonControls(camera2, renderer.domElement);
        firstPersonControls.lookSpeed = 0.05; // Set look speed
        firstPersonControls.movementSpeed = 10; // Set movement speed
        firstPersonControls.lookVertical = true; // Allow vertical look
        firstPersonControls.constrainVertical = true; // Constrain vertical look

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(110, 110, 10, 10);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2; // Correct rotation
        scene.add(floor);

        // Function to create walls

        const walls = [];
        const wallDirections = [];
        function createWall(x, z, rotation,direction) {
            const wallGeometry = new THREE.BoxGeometry(5, 10, 1);
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x999999 });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, 5, z);
            wall.rotation.y = rotation;
            scene.add(wall);
            walls.push(wall);
            wallDirections.push(direction);
            return wall;
        }

        // Generate walls for the boundaries
        for (let i = -10; i <= 10; i++) {
            createWall(-50, i * 5 + 2.5, Math.PI / 2,1); //left wall
            createWall(55, i * 5 + 2.5, Math.PI / 2,1); //right wall
            
            if(i!=0){
                createWall(i * 5 + 2.5, 54.5, 0,1); //bottom wall
                createWall(i * 5 + 2.5, -50, 0,1); //top wall
            }
        }

        const wall1 = createWall(0, 0, 0,1); // first segment
        const wall2 = createWall(0, 40, 0,1); // second segment
        const wall3 = createWall(0, -30, 0,1); // third segment

        // Function to move walls
        let level = 1;
        function moveWall(wall, speed) {
            if (wall) { // Ensure wall is defined
                const index = walls.indexOf(wall);
                if (index !== -1) {
                    wall.position.x += speed * wallDirections[index]; // Move in the specified direction
                    if (wall.position.x > 50) {
                        wallDirections[index] = -1; // Reverse direction
                    } else if (wall.position.x < -47) {
                        wallDirections[index] = 1; // Reverse direction
                    }
                }
            }
        }
        // Player
        const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(2.5, 1, 55);
        scene.add(player);
        let allowPlayerMovement = true;

        function resetPlayerPosition() {
            console.log("Resetting player position...");
            player.position.set(2.5, 1, 55); // Reset player position
            level = 1;
        }

        // Keyboard input
        const keyboard = {};
        window.addEventListener('keydown', event => {
            if (allowPlayerMovement) {
                keyboard[event.key] = true;
            }
        });
        window.addEventListener('keyup', event => {
            if (allowPlayerMovement) {
                keyboard[event.key] = false;
            }
        });


        //messages
        let gameWon = false;
        // function showWinMessage() {
        //     const messageContainer = document.getElementById('messageContainer');
        //     messageContainer.style.display = 'block';
        //     allowPlayerMovement = false;
        //     gameWon = true;
        // }

        function restartGame() {
            // const messageContainer = document.getElementById('messageContainer');
            // messageContainer.style.display = 'none';
            console.log("Restarting game...");
            player.position.set(2.5, 1, 55);
            gameWon = false;
        }

        //document.getElementById('restartButton').addEventListener('click', restartGame);
        // Game loop
        function animate() {
            controls.update();
            
            const speed = 0.5;
            // Move player
            if (allowPlayerMovement) {
                if (keyboard['ArrowUp'] && !checkCollision(player.position.x, player.position.z - speed)) player.position.z -= speed;
                if (keyboard['ArrowDown'] && !checkCollision(player.position.x, player.position.z + speed)) player.position.z += speed;
                if (keyboard['ArrowLeft'] && !checkCollision(player.position.x - speed, player.position.z)) player.position.x -= speed;
                if (keyboard['ArrowRight'] && !checkCollision(player.position.x + speed, player.position.z)) player.position.x += speed;
            }

            moveWall(wall1, speed * 0.8 * level);
            moveWall(wall2, speed * 0.8 * level);
            moveWall(wall3, speed * 0.8 * level);

            //check if the player reaches the door at the top wall and reset the player position 

            if (player.position.z < -50 && !gameWon) {
                level++;
                restartGame();
            }

            // in each frame, check if the player is colliding with any of the walls
            // if so, reset the player position
             if (checkCollision(player.position.x, player.position.z)) {
                 resetPlayerPosition();
             }

            camera2.position.copy(player.position);
            camera2.position.y += 5;
            camera2.rotation.copy(player.rotation); 

            // Render scene
            renderer.render(scene, isFirstPersonCamera ? camera2 : camera1);
            requestAnimationFrame(animate);
        }

           // Function to check collision with walls
        function checkCollision(x, z) {
            const boundary = 450;
            for (const wall of [wall1, wall2, wall3]) { // collisions with the moving walls
                if (Math.abs(wall.position.x - x) < 3 && Math.abs(wall.position.z - z) < 3) {
                    console.log("Collision detected with moving wall at position:", wall.position.x, wall.position.z);
                    resetPlayerPosition();
                    return true;
                }
            }

            if (Math.abs(x) > boundary || Math.abs(z) > boundary) {
                console.log("Collision detected with floor boundary.");
                return true;
            }
            for (const wall of walls) {
                if (Math.abs(wall.position.x - x) < 3 && Math.abs(wall.position.z - z) < 3) {
                    console.log("Collision detected with wall at position:", wall.position.x, wall.position.z);
                    return true;
                }
            }
            return false;
        }

        animate();
    </script>
</body>
</html>
